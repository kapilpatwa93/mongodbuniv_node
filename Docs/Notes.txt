Mongo :

1) Mongo creates db only after inserting first document

2) Mongo db find() returns cursor object i.e. we can use following
    --var c = db.movies.find()
    --c.hasNext()
    returns : true
    --c.next()
    returns : {"_id" : .....,"title" :....}

3) NodeJS driver uses WIRE protocol to connect with the MongoDB Server

Week 2 : CRUD

1) Object ID : _id : 12-Byte Hex String
            DATE(4)|Mac(3)|PID(2)|Counter(3)
               ____| ___  | __   | ___

2) Create : insertOne : used to create single document
            insertMany : user to create multiple documents
                        when ordered option set to false allows to continue update process even after there are errors while mass insert
                            eg: insertMany([{"key":"value"}],{"ordered":"false"})

3) Reading doc :
            Examples
            /** to match scalar fields*/
            db.movieDetails.find({"rated":"PG-13"}).pretty()

            /** to match object fields*/
            db.movieDetails.find({"tomato.meter": 100}).pretty()

            /** to match with array*/

            /** to exact match array */
            db.movieDetails.find({"writers": ["Ethan Coen", "Joel Coen"]}).count()
            // order of element in array of the query document matters

            /** it matches any of the value on the array*/
            db.movieDetails.find({"actors": ["Jeff Bridges"]}).count()

            /** to match the element in the array at specific location*/
            db.movieDetails.find({"actors.0": "Jeff Bridges"}).count()

            Projections

            /**to show only title field and ignoring the rest*/
            db.movieDetails.find({"rated": "PG-13"},{"title" : 1})
            /*this will by default show the _id field*/

            /**to forcefully ignore the _id field*/
            db.movieDetails.find({"rated": "PG-13"},{"title" : 1,"_id" : 0})


            /**to ignore the actors and writes field and displaying the rest*/
            db.movieDetails.find({"rated" : "PG-13"},{"actors" : 0, "writers" : 0})

4) Comparison Operator

        Examples

        db.movieDetails.find({"runtime" : {$gt : 90 }}).count()

        db.movieDetails.find({"runtime" : {$gt : 90 , $lt : 120}}).count()
        db.movieDetails.find({"runtime" : {$gte : 90 , $lte : 120}}).count()

        /*multiple fields*/

        db.movieDetails.find({"tomato.meter" : {$gte : 95 },"runtime" : {$gte : 180 }}).pretty()

        /** $ne also returns the doc which does not contain that field*/
        db.movieDetails.find({"rated" : {$ne :"UNRATED"}}).count()
        // returns all the doc that does not contain rated as "UNRATED" and all the docs that does not contain rated field itself

        /** $in returns the doc that contains any of the values in the array*/
        db.movieDetails.find({"rated" : {$in : ["PG-13", "G" , " PG"] }}).count()

        /** $nin returns the doc that does not contains any of the values in the array*/

        db.movieDetails.find({"rated" : {$nin : ["PG-13", "G" , " PG"] }}).count()

5 ) Element Operators
        Example

        /*docs that contains tomato.meter field*/
        db.movieDetails.find({"tomato.meter" : {$exists : true}}).count()

        /*docs that contains tomato.meter field*/
        db.movieDetails.find({"tomato.meter" : {$exists : false}}).count()

        /*docs that contains tomato.meter field of string type*/
        db.movieDetails.find({"tomato.meter" : {$type : "string"}}).count()

6) Logical Operators

        Example
        /*Logical Operators*/

        /*or operator*/

        db.movieDetails.find({
            $or: [
                {"tomato.meter": {$gt: 95 ,$lt : 97}},
                {"metacritic": {$gt: 95}}

            ]
        }).count()

        /*and*/

        db.movieDetails.find(
                {
                    $and : [
                        {
                            "metacritic" : { $gte : 93}
                        },
                        {
                            "metacritic" : {$exists : true}
                        }
                    ]
                }
        ).count()


        /*nested $and and $or*/

        db.movieDetails.find({
                    $or: [
                        {
                            $and: [
                                {"metacritic": {$gte: 97}},
                                {"metacritic": {$exists: true}}
                            ]
                        }, {
                            $and: [
                                {"tomato.meter": {$gte: 98}},
                                {"tomato.meter": {$exists: true}}
                            ]
                        }
                    ]
                },
                {"title": 1, "metacritic": 1, "tomato.meter": 1}
        ).pretty()

7) Regex
    Example
    /*$regex*/

    db.movieDetails.find({"awards.text" : {$regex : /^Won\s.*/}}).count()
    /*returns all the docs that contains Won as first word in awards.text field*/

8) Array Operators

    Example
    /*Array operators*/
    /*it returns all the docs that contains all the element in $all array irrespective of their order*/
    db.movieDetails.find({ "genres" : {$all : ["Crime","Comedy", "Drama"]}},{"genres":1}).count()

    /*matches the size of the array*/
    db.movieDetails.find({"countries" : {$size : 3}},{"countries" : 1}).pretty()

    db.movieDetails.find({"tomato.meter" : 50 ,"tomato.fresh" : 89},{"tomato" : 1}).count()

    /*if boxOffice is array of object that contains contry and revenue as field*/

    /*if you want to get the doc that contains country as UK and revenue $gt 10*/
    db.movieDetails.find({boxOffice : {"country" : "UK", "revenue" : {$gt : 10}}}).pretty();
    /*this query will not work as it will return doc that contains country UK and revenue gt 10 in diff ojbects of boxOffice Array*/

    /*to get the expect doc use $elemMatch*/
    db.movieDetails.find({boxOffice : {$elemMatch : { country : "UK","revenue" : {$gt : 10}}}}).pretty()
    /*this will return the doc that contains country UK and revenue gt 10 in single object of boxOffice array*/


9) Update :
  updateOne

        for scalar
    updateSpecific fields
    a) $set is used to add or update the field if exist
    b) $inc is used to increment/decrement numerical(integer/float) value


    db.movieDetails.find({"title" : "The Martian"}).pretty()
    db.movieDetails.updateOne({"title" : "The Martian"},{
        $inc : { "metacritic" : -10.5, "awards.wins" : 10 , },
        $set: {"poster" : "12345"}
    })

    /*refer here for more example*/
    https://docs.mongodb.com/v3.0/reference/operator/update-field/

    for array
        /*correct way*/
        db.up.updateOne({
            "_id" :ObjectId("58846be545f49165001af03d")
        },
                {$addToSet : { "boxOffice" : {$each : [{"country":"Italy" , "revenue" : 45}]}}})

        /*add prefectly in the array*/

        /*without using $each*/
        db.up.updateOne({
                    "_id" :ObjectId("58846be545f49165001af03d")
                },
                {$addToSet : { "boxOffice" : [{"country":"Germany" , "revenue" : 45}]}})
        /*removes first or last element 1:last -1 : first*/
        db.up.updateOne({
                    "_id" :ObjectId("58846be545f49165001af03d")
        },
                {
                    $pop : {"boxOffice" : 1}
                })


        db.up.updateOne({
            "_id" :ObjectId("58846be545f49165001af03d")

        },
                {
                    $unset : {"boxOffice.7" : 1}
                })
        /*sets the array to null*/
        db.up.updateOne({
            "_id" :ObjectId("58846be545f49165001af03d")

        },
                {
                    $pull : {"boxOffice" : null}
                })

        /*removes the null from the array*/

    updateMany

    replaceOne



---------------------------------Week3----------------------------
1)db.collection('companies').find(query).toArray(function(err,docs))

    the above syntax is known as chaining i.e find returns a cursor and pass it to toArray()
    which will call to db and fetch all the value and give to the toArray()

2)var cursor = db.collection('companies').find(query)

    it will not give the call to db
    it will just create a cursor and stream a data to application

3) var cursor = db.collection('companies').find(query)
    cursor.project(projection)

    even this is not going to call db
    it will prepare a query that will be called when using forEach()

4) For querying element inside array of object eg - milestone : [{"source_description" : "asasasasa"},{...}]
    we have to use
    a) query["milestones.source_description"] =
                {"$regex": options.milestones, "$options": "i"};

        because it gives output query like : { 'milestones.source_description': { '$regex': 'billion valuation', '$options': 'i' } }

     if we use
    b) query.milestone = {};
        query.milestone.source_description = {...}

        output query string  = { milestones: { source_description: { '$regex': 'billion valuation', '$options': 'i' } } }
        which is wrong while querying the db

5) Using dot notation for accessing the property inside the object
    eg : $query["ipo.valuation_amount"]  {$exists : true , $ne : null}

    eg ::@
        query["ipo.valuation_amount"] = null
        returns all the doc in which ipo.valuation_amount doesnt exist or is set to null

6) While Sorting
    cursor.sort function may contain object or array
    eg : cursor.sort({founded_year: -1});

    while giving multiple sort fields,use array because obj in js may change the order and array dont
    so use array
    eg :    cursor.sort([["founded_year", 1], ["number_of_employees", -1]]);


Books
    Science
        Chemistry
        Physics
            Classical Mechanics
            Quantum Mechanics

db.categories.insertOne({"_id": "Books", "parent": 0, "left": null, "right": "Science"})
db.categories.insertOne({"_id": "Science", "parent": "Books", "left": "Chemistry", "right": "Physics"})
db.categories.insertOne({"_id": "Chemistry", "parent": "Science", "left": null, "right": null})
db.categories.insertOne({"_id": "Physics", "parent": "Science", "left": "Classical Mechanics", "right": "Quantum Mechanics"})
db.categories.insertOne({"_id": "Classical Mechanics", "parent": "Physics", "left": null, "right": null})
db.categories.insertOne({"_id": "Quantum Mechanics", "parent": "Physics", "left": null, "right": null})

db.categories.insertOne({"_id": "Quantum Mechanics", "ancestors": ["Books", "Science", "Physics"], "parent": "Physics"})
db.categories.insertOne({"_id": "Classical Mechanics", "ancestors": ["Books", "Science", "Physics"], "parent": "Physics"})
db.categories.insertOne({"_id": "Physics", "ancestors": ["Books", "Science"], "parent": "Science"})
db.categories.insertOne({"_id": "Chemistry", "ancestors": ["Books", "Science"], "parent": "Science"})
db.categories.insertOne({"_id": "Science", "ancestors": ["Books"], "parent": "Books"})
db.categories.insertOne({"_id": "Books", "ancestors": [], "parent": null})


db.categories.insertOne({"_id": "Classical Mechanics", "parent": "Physics"})
db.categories.insertOne({"_id": "Quantum Mechanics", "parent": "Physics"})
db.categories.insertOne({"_id": "Physics", "parent": "Science"})
db.categories.insertOne({"_id": "Chemistry", "parent": "Science"})
db.categories.insertOne({"_id": "Science", "parent": "Books"})
db.categories.insertOne({"_id": "Books", "parent": null})


db.categories.insertOne({"_id": "Classical Mechanics", "children": []})
db.categories.insertOne({"_id": "Quantum Mechanics", "children": []})
db.categories.insertOne({"_id": "Physics", "children": ["Classical Mechanics", "Quantum Mechanics"]})
db.categories.insertOne({"_id": "Chemistry", "children": []})
db.categories.insertOne({"_id": "Science", "children": ["Physics", "Chemistry"]})
db.categories.insertOne({"_id": "Books", "children": ["Science"]})

db.categories.insertOne({"_id": "Classical Mechanics", "children": [], "descendants": []})
db.categories.insertOne({"_id": "Quantum Mechanics", "children": [], "descendants": []})
db.categories.insertOne({"_id": "Physics", "children": ["Classical Mechanics", "Quantum Mechanics"], "descendants": ["Classical Mechanics", "Quantum Mechanics"] })
db.categories.insertOne({"_id": "Chemistry", "children": [], "descendants": []})
db.categories.insertOne({"_id": "Science", "children": ["Chemistry", "Physics"], "descendants": ["Chemistry", "Physics", "Classical Mechanics", "Quantum Mechanics"]})
db.categories.insertOne({"_id": "Books", "children": ["Science"], "descendants": ["Science", "Chemistry", "Physics", "Classical Mechanics", "Quantum Mechanics"]})